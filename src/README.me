# Java Algorithms Practice Repository

This repository is dedicated to practicing fundamental **algorithms in Java**, focusing mainly on sorting techniques. The goal is to strengthen algorithmic thinking, improve understanding of time complexity, and build a solid foundation for more advanced data structures and algorithms.

I will continue updating this repository as I study new concepts.

---

## ðŸ“š Implemented Sorting Algorithms

Below are the six sorting algorithms currently included in this project:

### 1. **Bubble Sort**

A simple comparison-based algorithm that repeatedly swaps adjacent elements if they are in the wrong order.

* **Type:** Comparison sort
* **Stability:** Stable
* **Time Complexity:** O(nÂ²)

### 2. **Insertion Sort**

Builds the sorted array one element at a time by inserting elements into their correct position.

* **Type:** Comparison sort
* **Stability:** Stable
* **Time Complexity:** O(nÂ²)

### 3. **Selection Sort**

Repeatedly selects the smallest element from the unsorted portion and places it at the beginning.

* **Type:** Comparison sort
* **Stability:** Unstable
* **Time Complexity:** O(nÂ²)

### 4. **Merge Sort**

A divide-and-conquer algorithm that splits the array, recursively sorts the halves, and merges the results.

* **Type:** Divide and conquer
* **Stability:** Stable
* **Time Complexity:** O(n log n)

### 5. **Quick Sort**

Selects a pivot element, partitions the array, and recursively sorts each side.

* **Type:** Divide and conquer
* **Stability:** Unstable
* **Time Complexity:** O(n log n) average, O(nÂ²) worst

### 6. **Shell Sort**

An optimization of Insertion Sort that starts by comparing far elements and gradually reduces the gap.

* **Type:** Comparison sort
* **Stability:** Unstable
* **Time Complexity:** Depends on gap sequence (typically between O(n log n) and O(nÂ²))

---

## ðŸ“ˆ Big O Notation

Big O notation is used to describe the performance and scalability of algorithms. It expresses how the runtime grows as the input size increases.

Some common complexities:

* **O(1)** â€” Constant time
* **O(log n)** â€” Logarithmic time (e.g., binary search)
* **O(n)** â€” Linear time
* **O(n log n)** â€” Efficient sorting algorithms like Merge Sort and Quick Sort (average)
* **O(nÂ²)** â€” Basic sorting algorithms like Bubble, Insertion, and Selection Sort

Understanding Big O is essential for choosing the right algorithm depending on the size and nature of the data.

---

## ðŸ”„ Continuous Learning

This repository will be updated as I continue studying algorithms, data structures, and Java best practices.

More algorithms and improvements will be added over time.

---

Feel free to explore, test, and modify the implementations as needed!
